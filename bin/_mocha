#!/usr/bin/env node
'use strict';

/* eslint no-unused-vars: off */

const base = require('./base');
const Mocha = require('../');
const utils = Mocha.utils;
const mocha = base.mocha;
const files = base.mocha.files;
const program = base.program;
const cwd = process.cwd();

/**
 * Stop.
 */
const stop = () => {
  process.stdout.write('\u001b[2K');
};

/**
 * Show the cursor.
 */
const showCursor = () => {
  process.stdout.write('\u001b[?25h');
};

/**
 * Hide the cursor.
 */
const hideCursor = () => {
  process.stdout.write('\u001b[?25l');
};

/**
 * Exits Mocha when tests + code under test has finished execution (default)
 * @param {number} code - Exit code; typically # of failures
 */
const exitLater = code => {
  process.on('exit', () => {
    process.exit(Math.min(code, 255));
  });
};

/**
 * Exits Mocha when Mocha itself has finished execution, regardless of
 * what the tests or code under test is doing.
 * @param {number} code - Exit code; typically # of failures
 */
const exit = code => {
  const clampedCode = Math.min(code, 255);
  let draining = 0;

  // Eagerly set the process's exit code in case stream.write doesn't
  // execute its callback before the process terminates.
  process.exitCode = clampedCode;

  // flush output for Node.js Windows pipe bug
  // https://github.com/joyent/node/issues/6247 is just one bug example
  // https://github.com/visionmedia/mocha/issues/333 has a good discussion
  const done = () => {
    if (!draining--) {
      process.exit(clampedCode);
    }
  };

  const streams = [process.stdout, process.stderr];

  streams.forEach(stream => {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });

  done();
};

let runner;
let loadAndRun;
let purge;
let rerun;

// --watch
if (program.watch) {
  console.log();
  hideCursor();
  process.on('SIGINT', () => {
    showCursor();
    console.log('\n');
    process.exit(130);
  });

  const watchFiles = utils.files(cwd, program.watchExtensions);
  let runAgain = false;

  loadAndRun = () => {
    try {
      mocha.files = files;
      runAgain = false;
      runner = mocha.run(() => {
        runner = null;
        if (runAgain) {
          rerun();
        }
      });
    } catch (e) {
      console.log(e.stack);
    }
  };

  purge = () => {
    watchFiles.forEach(file => {
      delete require.cache[file];
    });
  };

  loadAndRun();

  rerun = () => {
    purge();
    stop();
    if (!program.grep) {
      mocha.grep(null);
    }
    mocha.suite = mocha.suite.clone();
    mocha.suite.ctx = new Mocha.Context();
    mocha.ui(program.ui);
    loadAndRun();
  };

  utils.watch(watchFiles, () => {
    runAgain = true;
    if (runner) {
      runner.abort();
    } else {
      rerun();
    }
  });
} else {
  // load

  mocha.files = files;
  runner = mocha.run(program.exit ? exit : exitLater);
}

process.on('SIGINT', () => {
  runner.abort();

  // This is a hack:
  // Instead of `process.exit(130)`, set runner.failures to 130 (exit code for SIGINT)
  // The amount of failures will be emitted as error code later
  runner.failures = 130;
});
